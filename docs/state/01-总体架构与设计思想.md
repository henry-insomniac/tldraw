# 总体架构与设计思想

目标：以“信号”为原语（Atom/Computed），提供自动依赖捕获、基于 epoch 的脏检查、可选增量历史、可控副作用调度与原子化事务，以极低成本支撑大规模细粒度响应。

核心机制
- 信号接口（src/lib/types.ts）：`get()/getDiffSince()/lastChangedEpoch/__unsafe__getWithoutCapture/children`
- 依赖捕获（src/lib/capture.ts）：全局 capture 栈；`maybeCaptureParent/startCapturingParents/stopCapturingParents`
- 原子与派生：`atom(name, value, { isEqual, historyLength, computeDiff })`；`computed(name, derive, opts)`/`@computed` 装饰器
- 全局 epoch（src/lib/transactions.ts）：`advanceGlobalEpoch/getGlobalEpoch`；比较 `haveParentsChanged()` 决定是否重算
- 历史缓冲（src/lib/HistoryBuffer.ts）：循环缓冲保存 diff；不可用时返回 `RESET_VALUE`
- 事务（src/lib/transactions.ts）：`transact/transaction` 支持嵌套、回滚与副作用清理；`getIsReacting/getReactionEpoch`
- 效果调度（src/lib/EffectScheduler.ts）：`react(name, fn, { scheduleEffect })` 与 `reactor` 可手动 stop

设计思想
- Lazy + Minimal：只在访问时计算，只在父发生变化时才计算；通过 `lastChangedEpoch` 数字比较避免遍历
- 独立与可组合：Atom 只管存值，Computed 只负责派生与捕获；副作用通过 EffectScheduler 独立调度
- 可增量：可选 `historyLength/computeDiff` + `withDiff()` 实现大对象的增量更新与回溯
- 热路径可逃逸：`__unsafe__getWithoutCapture` 打开读优化，不引入依赖；在 compute 内搭配使用

