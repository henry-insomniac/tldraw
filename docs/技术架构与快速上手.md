# tldraw 技术架构与快速上手指南

本文面向需要快速熟悉 tldraw 开源仓库（monorepo）的工程师，汇总技术栈、核心架构、目录结构、开发与测试流程以及常见上手路径。内容基于仓库内 README.md 与多处 CONTEXT.md（根目录与关键包）整理而成。

---

## 一、总体概览

- 项目定位：面向 React 的无限画布 SDK 与其应用生态（含 tldraw.com）。
- 仓库形态：TypeScript monorepo，Yarn Berry（v4）工作区，LazyRepo 增量构建。
- 关键版本：Node.js ≥ 20；React 18/19（peer）。
- 开发主阵地：`apps/examples`（示例与手册式用例，便于联动验证 SDK 改动）。

常用命令（根目录执行）：
- `yarn dev`：运行 examples 开发服务器（默认 5420 端口）。
- `yarn build`：按依赖拓扑增量构建全部包与应用（LazyRepo）。
- `yarn typecheck` / `yarn lint` / `yarn format`：类型检查 / ESLint / Prettier。
- `yarn test run`：在具体 workspace 下运行 Vitest（到对应包目录再执行）。
- `yarn e2e`：examples 端到端测试；`yarn e2e-dotcom`：dotcom E2E。
- `yarn context [-v|-r]`：快速查看附近或全仓库的 CONTEXT.md（AI/新人上手利器）。

---

## 二、目录与职责一览

顶层结构（节选）：

- `apps/`
  - `examples/`：SDK 示例与演示，开发验证首选环境。
  - `docs/`：tldraw.dev 文档站（Next.js 15 + MDX + SQLite + Algolia）。
  - `dotcom/`：tldraw.com 完整应用栈（前端 + Cloudflare Workers + 资产/同步/图片处理等）。
  - `vscode/`：VSCode 扩展（.tldr 文件渲染与编辑）。
  - 其他：`analytics/`、`bemo-worker/` 等业务/服务应用。

- `packages/`
  - `@tldraw/editor`：核心编辑器引擎（无具体 UI/形状/工具）。
  - `@tldraw/tldraw`：完整 SDK（带 UI、形状、工具与常用集成）。
  - `@tldraw/store`：基于信号的客户端记录存储（历史、迁移、IndexedDB）。
  - `@tldraw/state`：细粒度 signals 响应式系统（Atom/Computed、事务、差分历史）。
  - `@tldraw/tlschema`：类型定义、校验器与迁移。
  - `@tldraw/sync` / `@tldraw/sync-core`：多人协作/实时同步。
  - `@tldraw/utils`、`@tldraw/validate`、`@tldraw/state-react` 等配套包。

- `templates/`：Vite、Next.js、Vue、Cloudflare 同步、AI、Workflow 等起步模板。
- `assets/`：图标/字体/多语言等集中资产，`yarn refresh-assets` 同步打包。
- `internal/`：共享配置、脚本与内部工具（bisect、health-worker 等）。

---

## 三、核心技术架构

### 1. 三层 SDK 模型

1) `@tldraw/editor`（引擎层）
- 提供编辑器核心：事件系统、工具状态机（StateNode）、ShapeUtil 形状抽象、绑定（Binding）机制、相机/选择/几何/命中测试等。
- 使用 `@tldraw/state` 实现细粒度响应式；通过 `@tldraw/store` 管理文档记录与历史。
- 无 UI/形状/工具具体实现，专注“可编排的编辑能力”。

2) `@tldraw/tldraw`（完整 SDK）
- 在引擎层之上集成默认 UI、工具与形状，实现“开箱即用”。
- 默认形状：文本/自由绘制/几何/箭头/便签/线/框/高亮/图片/视频/书签/嵌入等。
- 完整工具集：选择/手形/橡皮/激光/缩放及各形状创建工具；响应式 UI（桌面/移动）。
- 外部内容处理（拖拽/粘贴/URL/SVG/Embed/Excalidraw 导入等）与资产管线（校验、去重、预览、后台处理）。

3) `@tldraw/store`（数据层）
- 类型安全的记录存储，带校验、历史与迁移；本地持久化（IndexedDB）。
- 与 signals 深度集成，变更驱动视图与计算增量更新。

### 2. 响应式与状态

- `@tldraw/state`：
  - Atom（可变）/Computed（派生），自动依赖捕获，基于 epoch 的脏检查；事务（transact）保证原子性与回滚；HistoryBuffer 支持差分历史与增量计算；`unsafe__withoutCapture` 面向热点路径性能。
  - 与 React 结合通过 `@tldraw/state-react`，实现最小化重渲染与高性能订阅。

- 模式要点：
  - 编辑器与 Store 全量响应式；派生值按需计算并缓存；批量变更避免级联重算。

### 3. 形状/工具/绑定机制

- ShapeUtil：定义形状几何、渲染、指示器、交互与序列化；扩展自定义形状的首选切入点。
- StateNode：工具以分层状态机实现（选择工具含 Brushing/Translating/Resizing/Rotating/Crop/Editing 等子状态）。
- BindingUtil：描述形状间关系（如箭头吸附/绕障碍路由/关系维护与视觉反馈）。

### 4. 多人协作与后端集成

- `@tldraw/sync`（WebSocket/DO 架构）：
  - 文档状态以结构化 diff 同步；Presence（光标/选择）独立于文档状态；断线重连策略。
  - Cloudflare Workers + Durable Objects 实现可扩展实时后端；R2 资产存储与图片处理链路。

- tldraw.com（apps/dotcom）
  - 前端：React + Vite + Clerk（鉴权）+ FormatJS（i18n）。
  - 后端：多 Worker（sync/asset-upload/image-resize 等）；数据库（PostgreSQL + Rocicorp Zero 同步层）。

### 5. 文档站与内容链路（apps/docs）

- Next.js 15（App Router）+ MDX；API Extractor 生成 TS API 参考；SQLite 存储内容与索引；Algolia 搜索。
- 构建链路：拉取包导出 → 生成 API Markdown → 刷新内容与索引（`yarn refresh-everything`）。

### 6. 构建与质量

- 构建：LazyRepo 增量构建（`lazy.config.ts`），只构建受影响工作区；并行运行；缓存。
- 质量：ESLint（`eslint.config.mjs`）、Prettier、Husky 钩子；API Extractor 校验公共 API；严格 TS 配置与工作区引用。

---

## 四、快速上手（开发者）

### 1) 环境准备

- Node.js ≥ 20；建议开启 Corepack 确保 Yarn 版本：
  - `npm i -g corepack`
- 安装依赖：
  - `yarn`

### 2) 启动与开发

- 运行 examples：`yarn dev` → 打开 `http://localhost:5420`
- 变更 SDK 代码后，examples 会即时反映；如修改资产，执行 `yarn refresh-assets`。

### 3) 调试与阅读路径

- 从 `apps/examples` 入手，跟随示例验证 API 与行为。
- 利用 `yarn context -v` 查看当前目录最近的 `CONTEXT.md`，快速建立心智模型。
- 关键阅读顺序建议：
  1. `packages/editor`：了解 Editor、StateNode、ShapeUtil、Binding 与 managers。
  2. `packages/tldraw`：默认形状/工具/UI 覆盖点与外部内容处理链路。
  3. `packages/state` / `packages/store`：signals 与存储/历史/迁移机制。
  4. `apps/examples`：如何编写与分类示例；`writing-examples.md` 规范。

### 4) 常用脚本与构建测试

- 构建：`yarn build`（全量）或在具体包目录构建。
- 类型/规范：`yarn typecheck`、`yarn lint`、`yarn format`。
- 单测（Vitest）：
  - 进入具体包（如 `packages/editor`）后执行：`yarn test run`；
  - 过滤：`yarn test run --grep "pattern"`。
- 端到端（Playwright）：`yarn e2e`（examples）、`yarn e2e-dotcom`（dotcom）。

### 5) 与框架集成速览

- 最简用法：
  ```tsx
  import { Tldraw } from 'tldraw'
  import 'tldraw/tldraw.css'

  export default function App() {
    return <div style={{ position: 'fixed', inset: 0 }}><Tldraw /></div>
  }
  ```
- 选择性引入：仅引擎样式 `import '@tldraw/editor/editor.css'`。
- 模板：`templates/`（Vite/Next/Vue/Cloudflare/AI 等）或使用 `npm create tldraw` 脚手架。

---

## 五、扩展与自定义

### 自定义形状（ShapeUtil）
- 在 `@tldraw/tlschema` 定义类型 → 实现 `ShapeUtil` 的 `getGeometry/component/indicator` → 注册到编辑器。

### 自定义工具（StateNode）
- 以状态机组织交互：在 `onEnter/onExit` 与 `onPointerDown/Move/Up` 等事件中读写编辑器状态与 Store；必要时分解为子状态。

### 自定义 UI/组件覆盖
- 通过 `components` 覆盖默认 UI；保留响应式与可访问性；参考默认实现的结构化分层（Providers、Panels、Dialogs、Toasts、Minimap 等）。

### 外部内容与资产
- 统一处理文件/URL/SVG/富文本/Embed 等；内置校验、去重、预览与后台上传；支持自定义 handler。

---

## 六、性能与工程实践

- 渲染：视口裁剪、几何缓存与失效、命中测试优化；Minimap WebGL。
- 响应式：精准依赖追踪与批量变更；热点路径可用 `__unsafe__getWithoutCapture()`。
- 内存：事件与反应器清理；资产去重；历史裁剪；形状工具按需释放。
- 最佳实践：
  - 用事务批量更新；为复杂对象提供 `isEqual` 自定义相等；避免无谓依赖捕获。
  - 变更公共 API 后运行 `yarn api-check`；提交前务必 `yarn typecheck`。

---

## 七、常见问题与排错建议

- 端口与服务：`yarn dev` 默认 5420；若占用可临时调整或关闭其它进程。
- 测试很慢：避免在仓库根目录直接 `yarn vitest`，进到目标包后用 `yarn test run` 并配合 `--grep`。
- Yarn 版本：使用 Corepack 固定 Yarn 4；不要用 npm/pnpm 混装依赖。
- 资产未生效：修改 `/assets` 后运行 `yarn refresh-assets`。
- 不了解模块职责：在相应目录运行 `yarn context -v` 阅读最近的 CONTEXT.md。

---

## 八、进一步阅读（按优先级）

1) 根目录 `CONTEXT.md`：总体架构与工作流速览。
2) `packages/editor/CONTEXT.md`：引擎核心（StateNode/ShapeUtil/Binding/Managers）。
3) `packages/tldraw/CONTEXT.md`：完整 SDK 的形状/工具/UI/外部内容系统。
4) `packages/state/CONTEXT.md` 与 `packages/store/CONTEXT.md`：signals、事务、历史与存储。
5) `apps/docs/CONTEXT.md`：文档站内容系统与生成链路。
6) `apps/examples/writing-examples.md`：示例编写规范与分类建议。

---

## 九、附：关键脚本与命令速查

- 开发：`yarn dev` | `yarn dev-app`（dotcom 前端）| `yarn dev-docs`（文档站）| `yarn dev-vscode`。
- 构建：`yarn build` | `yarn build-package`（SDK 包）| `yarn build-app`（dotcom 前端）| `yarn build-docs`。
- 质量：`yarn typecheck` | `yarn lint` | `yarn format` | `yarn api-check`。
- 测试：`yarn test run [--grep]` | `yarn vitest`（全量，谨慎）| `yarn e2e` | `yarn e2e-dotcom`。
- 资产/内容：`yarn refresh-assets` | `yarn refresh-content` | `yarn refresh-api` | `yarn refresh-everything`。
- 上下文：`yarn context [-v|-r]` 快速定位并阅读 CONTEXT.md。

---

如需我继续补充特定模块（例如 SelectTool 状态机、Sync 后端协议、或模板最佳实践）的深入说明，请告知关注点与优先级。

---

## 十、Canvas 与 React 的数据交互与职责分层（重点）

本节说明“画布渲染（Canvas）与 React 组件”之间如何解耦与协作，以及数据/事件如何在两者之间流动。

### 1) 职责分层

- Editor（核心编排，packages/editor）
  - 持有编辑状态与文档数据的唯一事实来源（通过 `@tldraw/store`）。
  - 工具状态机（`StateNode`）处理输入事件与交互流程（选择、拖拽、缩放、绘制等）。
  - 提供只读选择器/派生接口（如 `getRenderingShapes`、`getShapePageTransform`、`getShapeGeometry`、`getCamera`）。
  - 做命中测试、几何计算、吸附/对齐、光标/brush/指示器等“业务逻辑”。

- Store（文档数据）
  - 记录 Shape/Binding/Page/Asset 等结构化数据；提供历史与迁移；触发响应式更新。

- React UI（视图层）
  - 通过 `@tldraw/state-react` 的 `useValue/useQuickReactor/useStateTracking` 等 hooks 订阅 Editor/Store 的信号。
  - 以极少的重渲染、直接操作 DOM/CSS transform 的方式高效更新视觉状态。
  - 负责呈现：形状容器、指示器（handles/selection/snapline）、覆盖层、工具条/菜单等 UI。

- ShapeUtil（形状抽象，连接数据与渲染）
  - 定义几何/命中/指示器与“形状内部”的 React 渲染函数（`util.component`）。
  - React 组件只负责“如何画”，不关心“画什么/何时画”——这些由 Editor 的派生选择器与订阅节流控制。

### 2) 数据流（自上而下：状态 → 视图）

1. Store/Editor 内部状态变化（例如 StateNode 处理完一次指针事件后创建/移动形状）。
2. 信号触发：`@tldraw/state` 记录依赖的 Computed 脏化，相关选择器（如 `getRenderingShapes`）变为待计算。
3. React 订阅层：`useValue/useQuickReactor/useStateTracking` 在需要时重算并最小化更新点。
4. 视图更新：
   - DefaultCanvas 将相机值（`getCamera`）转为 CSS transform，整体位移/缩放 HTML/SVG 层。
   - Shape 组件读取 `getShapePageTransform`、`getShapeGeometry(bounds)`，仅更新容器的 `transform/width/height/opacity/z-index/display` 等样式（轻量 DOM 操作）。
   - 形状内部 JSX（由 ShapeUtil 提供）仅在 props/meta 内容改变时重渲染（`areShapesContentEqual` 做浅层对比 + `useStateTracking` 避免无关订阅）。

结果：渲染层遵循“少算少渲染”的策略，大多数更新演变为 CSS 变换与可见性切换，React 仅在确需变更形状内容时才重新渲染。

### 3) 事件流（自下而上：DOM → 逻辑）

1. DOM 事件捕获：DefaultCanvas 通过 `useCanvasEvents` 在根层绑定 `pointerdown/up/enter/leave`、`dragover/drop`、`touchstart/end` 等；`pointermove` 直接挂到 `document.body`，保证移动时坐标持续同步。
2. 事件转换：事件被转换为 Editor 内部统一的 `dispatch({ type: 'pointer', target: 'canvas', name: 'pointer_move' | ... , ...getPointerInfo })`。
3. 工具状态机处理：当前工具（`StateNode`）基于事件与上下文决定状态迁移与副作用（创建/变更形状、更新选择、相机移动等）。
4. Store 变更 → 信号触发 → 视图订阅更新（回到“数据流”步骤）。

要点：React 不直接处理复杂交互逻辑；它只分发语义化事件给 Editor，真正的编辑学逻辑在工具状态机与 Editor 内完成。

### 4) 图层与对齐

- DefaultCanvas 采用多层结构：
  - 背景层（Background/Grid/SvgDefs）、形状层（`.tl-html-layer.tl-shapes`）、覆盖层（handles/selection/snap/scribble/协作指示/前景 UI）。
  - 通过 `useQuickReactor('position layers', ...)` 监听相机变化，计算缩放时的精度补偿（offset）并统一设置各 HTML 层的 transform，确保 HTML 与 SVG 叠层像素对齐、避免亚像素抖动。

### 5) 性能策略（与 React 协作）

- 精准订阅：`useValue/useQuickReactor` 仅对必要派生值建立依赖；热点路径可用 `unsafeGetWithoutCapture` 读取，避免意外依赖。
- 容器与内容拆分：容器负责 transform/尺寸/可见性，内部 JSX 受控重渲染；大量移动仅修改容器样式。
- 视口裁剪：`getCulledShapes()` 将不可见形状 `display:none`，避免不必要布局/绘制。
- WebGL/特殊渲染：如 Minimap 使用 WebGL；其与 React 通过 Editor 的派生状态对齐，不与主渲染竞争。

### 6) 扩展建议

- 自定义形状：实现 ShapeUtil 的 `component/indicator/getGeometry`，其余交互仍走 Editor → 订阅 → React 的既有管线。
- 自定义交互：扩展 `StateNode`（工具）以接管事件与逻辑，不要把业务逻辑塞进 React 组件。
- 自定义 UI：用 `useEditorComponents` 的覆盖系统替换工具栏/指示器/对话框等，不影响核心数据/事件流。

### 7) 数据/事件流示意图（ASCII）

```
┌────────────────────────────────────────────────────────────────────────────┐
│                                浏览器 DOM                                  │
│ (pointerdown/up, pointermove@document.body, drag/drop, touchstart/end...)  │
└──────────────┬─────────────────────────────────────────────────────────────┘
               │ 事件监听（React 层 hooks）
               ▼
┌────────────────────────────────────────────────────────────────────────────┐
│ useCanvasEvents / useGestureEvents / useDocumentEvents（React hooks）       │
│  - 规范化 pointer/touch/drag 事件                                           │
│  - editor.markEventAsHandled / wasEventAlreadyHandled                       │
│  - editor.dispatch({ type:'pointer', target:'canvas', name:'...', info })    │
└──────────────┬─────────────────────────────────────────────────────────────┘
               │ 语义化事件分发
               ▼
┌────────────────────────────────────────────────────────────────────────────┐
│ Editor（业务核心）                                                          │
│  - 工具状态机 StateNode（Select/Hand/ShapeTools...）                        │
│  - 命中测试/几何/吸附/相机/选择/文本/历史/偏好等管理器                      │
│  - 对 Store 进行原子变更（batch/transactions）                              │
└──────────────┬─────────────────────────────────────────────────────────────┘
               │ 状态变更（记录级）
               ▼
┌────────────────────────────────────────────────────────────────────────────┐
│ Store（@tldraw/store）                                                      │
│  - 信号：@tldraw/state（Atom/Computed/HistoryBuffer/Epoch）                 │
│  - 记录：Shape/Binding/Page/Asset/Instance...                               │
│  - 触发依赖的 Computed 脏化与订阅                                           │
└──────────────┬─────────────────────────────────────────────────────────────┘
               │ 响应式通知（最小必要）
               ▼
┌────────────────────────────────────────────────────────────────────────────┐
│ React 订阅层（@tldraw/state-react）                                         │
│  - useValue / useQuickReactor / useStateTracking                             │
│  - DefaultCanvas: 读取 camera → 设置 HTML/SVG 层 transform                  │
│  - Shape: 读取 transform/geometry → 设置容器样式；内部 JSX 稀疏重渲染       │
└──────────────┬─────────────────────────────────────────────────────────────┘
               │ DOM/CSS 轻量更新
               ▼
┌────────────────────────────────────────────────────────────────────────────┐
│ 画布呈现层（HTML/SVG/WebGL）                                                │
│  - 背景/Grid/SvgDefs                                                         │
│  - 形状容器（CSS transform/宽高/opacity/z-index/display）                   │
│  - 覆盖层（handles/selection/snap/scribble/minimap/collab 等）              │
└────────────────────────────────────────────────────────────────────────────┘
```

图例与要点：
- 事件只做一次语义化分发（editor.dispatch），复杂交互全部在 Editor/StateNode 内完成。
- 渲染主要通过 CSS transform 与可见性切换完成；形状内部 JSX 仅在内容变更时重绘。
- 信号（signals）保证“改哪里、动哪里”，避免全局重渲染；pointermove 直接挂 body 保证连续性。
