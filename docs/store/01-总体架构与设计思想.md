# 总体架构与设计思想

目标：以信号（@tldraw/state）为基础，为“有类型的记录集合”提供高性能、可迁移、可查询、可插拔副作用的存储内核。

核心构件
- Store（src/lib/Store.ts）
  - 记录存储：`AtomMap<Id, Record>`（每条记录一个 atom，细粒度响应）
  - 历史：`history: Atom<number, RecordsDiff>`（批量变更流）
  - 查询：`StoreQueries`（索引/过滤/增量更新）
  - Schema：`StoreSchema`（记录类型注册/验证/迁移）
  - SideEffects：生命周期钩子（before/after create/change/delete、operation complete）
- 记录体系：`BaseRecord` + `RecordType`
  - 统一 id/typeName；默认值、校验器、scope（document/session/presence）
- Reactive 容器：`AtomMap` + `ImmutableMap`
  - Map 的响应式替身，值存在独立 atom；支持 get/unsafe 无捕获、deleteMany 等批量 API
- 变更与历史：`RecordsDiff` + HistoryAccumulator
  - 变更三元组（added/updated/removed）；源（user/remote）；合并相邻来源、逐帧节流
- 查询与索引：`StoreQueries` + `executeQuery`
  - RSIndex（属性值→记录集合）；通过 diff 增量维护；reactive 输出
- 迁移：`migrate.ts`
  - 版本化迁移序列，依赖处理、正向/回滚、legacy 兼容

关键设计思想
- 细粒度响应：每条记录用独立 atom 存储；查询/索引依赖记录级 diff 增量更新
- 强类型保证：RecordType/StoreSchema 驱动类型安全与验证；Validator 支持“利用已知良好版本”的优化
- 可演进数据：序列化快照包含 schema 版本；加载时自动迁移；迁移失败显式报错
- 生命周期解耦：副作用统一在 Store 层注册，CRUD 前后可拦截或清理，支持批处理/事务
- 性能优先：
  - 读：`__unsafe__getWithoutCapture` 避免热路径订阅；ComputedCache 按记录缓存昂贵计算
  - 写：`atomic()` 事务包裹；HistoryAccumulator 合并相邻来源 + `throttleToNextFrame` 降频通知
  - 查：索引增量维护；`ImmutableMap` + 批量 deleteMany；查询结果按需缓存

与上层（@tldraw/editor）的关系
- Editor 把 Store 作为文档/实例/游标等记录的“单一事实源”；
- Editor 的派生（矩阵/边界/清单）与 UI 渲染订阅 Store；
- Editor 的 SideEffects 结合 StoreSideEffects 构建形状/绑定的业务一致性。

