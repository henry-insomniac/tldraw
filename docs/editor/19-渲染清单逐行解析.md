# 渲染清单逐行解析：getUnorderedRenderingShapes → getRenderingShapes

本文逐行拆解 Editor 如何将 Store 记录转为渲染清单，并解释 index/backgroundIndex/opacity 与层级关系。

入口与目的
- 入口：`getUnorderedRenderingShapes(useEditorState: boolean)`（packages/editor/src/lib/editor/Editor.ts:3960）
- 封装：`getRenderingShapes()` 对结果按 id 排序，保证 DOM 稳定（packages/editor/src/lib/editor/Editor.ts:4094）。

逐行解析
- 初始化清单与索引池：
  - `const renderingShapes: TLRenderingShape[] = []`（packages/editor/src/lib/editor/Editor.ts:3972）
  - `let nextIndex = maxShapesPerPage * 2; let nextBackgroundIndex = maxShapesPerPage`（:3974）
    - 约定：前景 index 从 2N 开始、背景从 N 开始，保证足够的“间隔”供子树占位。

- 擦除集与局部递归函数：
  - `const erasingShapeIds = this.getErasingShapeIds()`（:3977）
  - `addShapeById(id, opacity, isAncestorErasing)`（:3979）
    - 读形状：`const shape = this.getShape(id)`，无则返回（:3980）
    - 隐藏分支：`if (this.isShapeHidden(shape))`（:3983）
      - 仍遍历子节点（允许子节点覆盖隐藏状态）：`getSortedChildIdsForParent(id)`（:3986）
      - 将 `isErasing` 传给子节点：`isAncestorErasing || erasingShapeIds.includes(id)`（:3985）

- 不隐藏时的属性叠加：
  - 不透明度：`opacity *= shape.opacity`（:3992）
  - 获取 util：`const util = this.getShapeUtil(shape)`（:3994）
  - 编辑器态才考虑“正在擦除”：
    - `isShapeErasing = !isAncestorErasing && erasingShapeIds.includes(id)`（:3997）
    - 命中则降低透明度：`opacity *= 0.32`（:3999）

- 推入清单：
  - `renderingShapes.push({ id, shape, util, index: nextIndex, backgroundIndex: nextBackgroundIndex, opacity })`（:4003）
  - 自增索引池：`nextIndex += 1; nextBackgroundIndex += 1`（:4012）

- 子树处理与“背景占位”技巧：
  - 获取子节点：`const childIds = this.getSortedChildIdsForParent(id)`（:4015）
  - 背景占位：`if (util.providesBackgroundForChildren(shape)) { ... }`（:4019）
    - 保存现场：`backgroundIndexToRestore = nextBackgroundIndex`（:4020）
    - 让子节点背景层“贴近”前景层：`nextBackgroundIndex = nextIndex`（:4021）
    - 为子树预留 index 段：`nextIndex += maxShapesPerPage`（:4022）
      - 含义：背景元素（如 Frame 的“背景”）需要在子元素之下，但它们都属于同一父项，为了 z-index 正确，需要前景与背景层的“索引池”交错分配。
  - 递归子节点：`addShapeById(childId, opacity, isAncestorErasing || isShapeErasing)`（:4025）
  - 若发生占位，恢复背景索引池：`nextBackgroundIndex = backgroundIndexToRestore`（:4029）

- 页面与 offscreen 选择：
  - `const pages = useEditorState ? [this.getCurrentPage()] : this.getPages()`（:4036）
  - 遍历根级子节点填充清单：`for childId of getSortedChildIdsForParent(page.id) addShapeById(childId, 1, false)`（:4038–4040）

- 返回清单：`return renderingShapes`（:4043）。

排序封装与 DOM 稳定性
- `getRenderingShapes()` 将清单按 id 排序（不是 z-index），从而保持 React key/DOM 稳定，z 次序交由 `index/backgroundIndex` 控制（packages/editor/src/lib/editor/Editor.ts:4094）。

关键设计算法
- 双索引池：前景/背景索引分开推进，遇到“提供背景的父形状”（如 Frame），为其子树临时“切换背景池”与“预留前景段”，确保父背景 < 子元素 < 父前景 的层次。
- 非复合擦除：降低透明度仅在“最靠近的擦除祖先”一次生效，避免多次相乘导致透明度过低。
- 隐藏但仍遍历：支持子节点覆盖父隐藏策略（如局部显隐逻辑）。

与 UI 的契合点（简述）
- UI 读取清单并在容器层设置：`transform/width/height/opacity/z-index/display`；内部 JSX 稀疏重绘。
- Frame/背景相关的 `backgroundIndex` 直接影响 UI 中“背景容器”的 z-index，确保视觉正确。

延伸阅读：
- 事件调度序列深挖：`20-事件调度序列深挖.md`
- 总览剖析：`../Editor.ts-技术架构剖析.md`
