# 30 分钟动手任务清单（插桩点 + 预期日志）

目的：用最少改动跑通“事件 → 相机/坐标 → 渲染清单”的关键链路，形成可验证的心智模型。完成后你应能看懂一次拖动/缩放时，Editor 内部发生了什么。

预备
- 运行 examples：`yarn dev`（默认 http://localhost:5420）
- 建议使用浏览器 DevTools Console 观察日志

约定
- 所有插桩均标注 `// [debug]`，完成后全文搜索移除即可
- 以下插桩仅用于本地开发，勿提交到主干

任务 A：事件调度总览（5–8 min）
1) 在 `packages/editor/src/lib/editor/Editor.ts` 的 `_flushEventForTick(info)` 开头加入：
```ts
// [debug]事件流总览
try { console.debug('[evt]', info.type, (info as any).name ?? ''); } catch {}
```
位置参考：约 10209 行附近（`_flushEventForTick(info)` 定义体的起始处）。

2) 试验操作与预期日志：
- 拖动画布（按空格 + 拖动）：应出现连续 `[evt] pointer pointer_move`；按下/抬起时有 `pointer_down` / `pointer_up`
- 捏合缩放（触摸板/触屏）：应出现 `[evt] pinch pinch_start` → 多次 `pinch` → `pinch_end`
- 鼠标滚轮：`[evt] wheel`（随后会按行为进入 zoom 或 pan）

任务 B：坐标换算与相机平移（8–10 min）
1) 在 `_updateInputsFromEvent(info)` 末尾加入：
```ts
// [debug]坐标换算
try { const p = this.inputs.currentPagePoint; console.debug('[pagePoint]', p.x.toFixed(1), p.y.toFixed(1)); } catch {}
```
位置参考：约 9515 行定义体末尾（成功写入 TLPOINTER 后）。

2) 在 `pointer_move` 的相机平移处（即时 pan）加入：
```ts
// [debug]即时平移
console.debug('[pan]', 'offset', offset.x, offset.y, 'cz', cz);
```
位置参考：约 10505–10514 行之间（`const offset = Vec.Sub(...); this.setCamera(new Vec(...), { immediate:true })` 这一段）。

3) 预期：拖动时 `pagePoint` 连续变化；开启空格拖动时出现 `[pan]` 日志，cz 为当前缩放。

任务 C：缩放围绕指针与跟随终止（5–7 min）
1) 在 `case 'wheel'` 与 `case 'pinch'` 中、调用 `_setCamera/new Vec(...)` 之前加入：
```ts
// [debug]缩放
console.debug('[zoom]', 'cx,cy,cz=', cx, cy, cz, 'screen=', x, y, 'delta=', dx ?? dy ?? dz ?? 0);
```

2) 监听停止跟随事件（在 UI 层更容易）：在 `packages/editor/src/lib/components/default-components/DefaultCanvas.tsx` 顶部组件内：
```ts
// [debug]停止跟随监听
useEffect(() => {
  const off = editor.on('stop-following', () => console.debug('[follow] stop'))
  return () => off()
}, [editor])
```

3) 预期：缩放日志显示以“当前屏幕点”为锚（缩放后相机变化抵消了鼠标点的屏幕漂移）；执行缩放/平移后应出现 `[follow] stop`（若之前处于 following 模式）。

任务 D：渲染清单规模与相机状态（5–7 min）
1) 在 `getRenderingShapes()` 返回前加入：
```ts
// [debug]渲染清单
try { console.debug('[render]', 'count', renderingShapes.length, 'cameraState', this.getCameraState()); } catch {}
```
位置参考：约 4094 行附近（`return renderingShapes.sort(sortById)` 前）。

2) 预期：快速拖动/缩放时，`cameraState` 由 `moving` 切回 `idle` 后，渲染清单日志才会明显稳定（避免运动中频繁重建清单）。

任务 E：清理（2–3 min）
- 搜索 `// [debug]` 并移除全部插桩
- 若改动过 UI 层，恢复 `DefaultCanvas.tsx`

附加：无需改源码的“临时观察”技巧（可选）
- 在 `DefaultCanvas` 中通过浏览器 DevTools `window.__editor = editor` 暴露实例，控制台直接执行：
  - `__editor.getCamera()` / `__editor.getRenderingShapes().length`
  - `__editor.on('before-event', e => console.debug(e))`（记得在卸载时移除）

